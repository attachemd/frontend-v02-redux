{"ast":null,"code":"import { AuthService } from \"./auth.service\";\nimport { TestBed } from \"@angular/core/testing\";\nimport { HttpClientTestingModule, HttpTestingController } from \"@angular/common/http/testing\";\nimport { RouterTestingModule } from \"@angular/router/testing\";\nimport { JwtHelperService, JwtModule } from \"@auth0/angular-jwt\";\nimport { UIService } from \"../shared/ui.service\";\nimport { of } from \"rxjs\";\nimport { Router } from \"@angular/router\";\nconst validAuthData = {\n  email: \"test@test.com\",\n  password: \"password\",\n  name: \"test\"\n};\nconst invalidAuthData = {\n  email: \"\",\n  password: \"\",\n  name: \"\"\n};\nconst uiServiceSpy = jasmine.createSpyObj(\"UIService\", {\n  loadingStateNotifier: undefined,\n  showSnackBar: undefined\n});\nlet actualIsLoadingState; // let localStore: any;\n\ndescribe('AuthService', () => {\n  let authService;\n  let jwtHelper;\n  let controller;\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [RouterTestingModule, HttpClientTestingModule, JwtModule.forRoot({\n        config: {\n          tokenGetter: () => {\n            return '';\n          }\n        }\n      })],\n      providers: [{\n        provide: UIService,\n        useValue: uiServiceSpy\n      }, AuthService, JwtHelperService]\n    });\n    authService = TestBed.inject(AuthService);\n    jwtHelper = TestBed.inject(JwtHelperService);\n    controller = TestBed.inject(HttpTestingController);\n    actualIsLoadingState = null; // localStore = {};\n    //\n    // spyOn(window.localStorage, 'getItem').and.callFake((key) =>\n    //     key in localStore ? localStore[key] : null\n    // );\n    // spyOn(window.localStorage, 'setItem').and.callFake(\n    //     (key, value) => (localStore[key] = value + '')\n    // );\n    // spyOn(window.localStorage, 'clear').and.callFake(() => (localStore = {}));\n  });\n  it('User register successfully', () => {\n    const response = {\n      \"response\": \"Registration Successful!\",\n      \"id\": 7,\n      \"email\": \"test@test.com\",\n      \"token\": {\n        \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\",\n        \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d4M\"\n      }\n    };\n    authService.registerUser(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    });\n    console.log(\"controller: \");\n    console.log(controller);\n    const request = controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/create/\"\n    }); // const request = controller.expectOne(\"api/user/create/\");\n\n    console.log(\"request: \");\n    console.log(request);\n    /* … */\n    // Answer the request so the Observable emits a value.\n\n    request.flush(response);\n    controller.verify(); // Now verify emitted valued.\n\n    expect(actualIsLoadingState).toEqual(true);\n  });\n  it('Registration passes through empty response', () => {\n    authService.registerUser(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    });\n    controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/create/\"\n    }).flush(null);\n    expect(actualIsLoadingState).toEqual(false);\n  });\n  it('Registration passes through email already exist', () => {\n    const response = {\n      \"email\": [\"user with this email already exists.\"]\n    };\n    authService.registerUser(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    });\n    controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/create/\"\n    }).flush(response);\n    expect(actualIsLoadingState).toEqual(false);\n  });\n  it('Registration passes through with error response', () => {\n    const status = 500;\n    const statusText = 'Internal Server Error';\n    const errorEvent = new ErrorEvent('API error'); // const error = {\n    //     \"email\": [\n    //         \"user with this email already exists.\"\n    //     ]\n    // }\n\n    let actualError;\n    authService.registerUser(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    }); // authService.registerUser(validAuthData).subscribe(\n    //     () => {\n    //         fail('next handler must not be called');\n    //     },\n    //     (error) => {\n    //         actualError = error;\n    //     },\n    //     () => {\n    //         fail('complete handler must not be called');\n    //     },\n    // );\n\n    controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/create/\"\n    }).flush(errorEvent, {\n      status,\n      statusText\n    }); // .flush(error);\n\n    expect(actualIsLoadingState).toEqual(false); // if (!actualError) {\n    //     throw new Error('Error needs to be defined');\n    // }\n    // console.log(\"actualError: \");\n    // console.log(actualError);\n    // expect(actualError.error).toBe(errorEvent);\n    // expect(actualError.status).toBe(status);\n    // expect(actualError.statusText).toBe(statusText);\n  });\n  it('User login successfully', () => {\n    const response = {\n      \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\",\n      \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d4M\"\n    };\n    authService.login(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    });\n    const request = controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/access/\"\n    }); // Answer the request so the Observable emits a value.\n\n    request.flush(response);\n    controller.verify(); // Now verify emitted valued.\n\n    expect(actualIsLoadingState).toEqual(true);\n  });\n  it('Login passes through user form fields empty', () => {\n    authService.login(invalidAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    }); // controller.expectOne(\n    //     {\n    //         method: \"POST\",\n    //         url: \"api/user/access/\"\n    //     }\n    // )\n    //     .flush(null);\n\n    expect(actualIsLoadingState).toEqual(false);\n  });\n  it('Login passes through with error response', () => {\n    const status = 500;\n    const statusText = 'Internal Server Error';\n    const errorEvent = new ErrorEvent('API error'); // const error = {\n    //     \"email\": [\n    //         \"user with this email already exists.\"\n    //     ]\n    // }\n\n    let actualError;\n    authService.login(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    }); // authService.registerUser(validAuthData).subscribe(\n    //     () => {\n    //         fail('next handler must not be called');\n    //     },\n    //     (error) => {\n    //         actualError = error;\n    //     },\n    //     () => {\n    //         fail('complete handler must not be called');\n    //     },\n    // );\n\n    controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/access/\"\n    }).flush(errorEvent, {\n      status,\n      statusText\n    }); // .flush(error);\n\n    expect(actualIsLoadingState).toEqual(false); // if (!actualError) {\n    //     throw new Error('Error needs to be defined');\n    // }\n    // console.log(\"actualError: \");\n    // console.log(actualError);\n    // expect(actualError.error).toBe(errorEvent);\n    // expect(actualError.status).toBe(status);\n    // expect(actualError.statusText).toBe(statusText);\n  });\n  it('Login passes through empty response', () => {\n    authService.login(validAuthData).subscribe(isLoadingState => {\n      actualIsLoadingState = isLoadingState;\n    });\n    controller.expectOne({\n      method: \"POST\",\n      url: \"api/user/access/\"\n    }).flush(null);\n    expect(actualIsLoadingState).toEqual(false);\n  }); // it('InitAuthListener', async () => {\n  //\n  //     await authService.initAuthListener()\n  //\n  //     expect(true).toEqual(true);\n  //\n  // });\n\n  it('Refresh access token successfully', () => {\n    spyOn(authService, 'getToken').and.returnValue(\"test\");\n    spyOn(authService, 'isToken').and.returnValue(true); // const payload = {\n    //     \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\"\n    // }\n    // const payload = {\n    //     \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH8\"\n    // }\n\n    const response = {\n      \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d8M\"\n    };\n    let actualIsAuth;\n    authService.refreshTokenOrDie().subscribe(isAuth => {\n      actualIsAuth = isAuth;\n    });\n    const request = controller.expectOne({\n      method: \"POST\",\n      url: \"/api/user/refresh/\"\n    }); // Answer the request so the Observable emits a value.\n\n    request.flush(response);\n    controller.verify(); // localStorage.removeItem('refresh');\n\n    let refresh = localStorage.getItem('refresh');\n    console.log(\"refresh: \");\n    console.log('%c refresh ', 'background: yellow; color: #000; padding: 10px;');\n    console.log(refresh); // Now verify emitted valued.\n\n    expect(actualIsAuth).toEqual(true);\n  });\n  it('Refresh ACCESS token passes through when empty or invalid REFRESH Token', () => {\n    spyOn(authService, 'getToken').and.returnValue(\"test\");\n    spyOn(authService, 'isToken').and.returnValue(false);\n    let actualIsAuth;\n    authService.refreshTokenOrDie().subscribe(isAuth => {\n      actualIsAuth = isAuth;\n    }); //\n    // const request = controller.expectOne(\n    //     {\n    //         method: \"POST\",\n    //         url: \"/api/user/refresh/\"\n    //     }\n    // );\n    //\n    // Answer the request so the Observable emits a value.\n    // request.flush(response);\n    // controller.verify();\n    // Now verify emitted valued.\n\n    expect(actualIsAuth).toEqual(false);\n  });\n  it('Refresh ACCESS token passes through with error response', () => {\n    const status = 500;\n    const statusText = 'Internal Server Error';\n    const errorEvent = new ErrorEvent('API error');\n    spyOn(authService, 'isToken').and.returnValue(true);\n    let actualIsAuth;\n    authService.refreshTokenOrDie().subscribe(isAuth => {\n      actualIsAuth = isAuth;\n    });\n    controller.expectOne({\n      method: \"POST\",\n      url: \"/api/user/refresh/\"\n    }).flush(errorEvent, {\n      status,\n      statusText\n    });\n    expect(actualIsAuth).toEqual(false);\n  });\n  it('ACCESS tokens alive', () => {\n    spyOn(jwtHelper, 'isTokenExpired').and.returnValue(false);\n    let actualIsBothTokensAlive;\n    authService.isBothTokensAlive().subscribe(isBothTokensAlive => {\n      actualIsBothTokensAlive = isBothTokensAlive;\n    }); // Now verify emitted valued.\n\n    expect(actualIsBothTokensAlive).toEqual(true);\n  });\n  it('REFRESH tokens alive or not', () => {\n    spyOn(jwtHelper, 'isTokenExpired').and.returnValue(true);\n    spyOn(authService, 'refreshTokenOrDie').and.returnValue(of(true));\n    let actualIsBothTokensAlive;\n    authService.isBothTokensAlive().subscribe(isBothTokensAlive => {\n      actualIsBothTokensAlive = isBothTokensAlive;\n    }); // Now verify emitted valued.\n\n    expect(actualIsBothTokensAlive).toEqual(true);\n  });\n  it('Token check pass with valid token', () => {\n    let access = \"test\";\n    spyOn(window.localStorage, 'getItem').and.returnValue(access);\n    spyOn(jwtHelper, 'decodeToken').and.returnValue(\"valid\");\n    let actualIsToken;\n    actualIsToken = authService.isToken(\"access\"); // Now verify emitted valued.\n\n    expect(actualIsToken).toEqual(true);\n  });\n  it('Token check pass with invalid token', () => {\n    let access = \"test\";\n    spyOn(window.localStorage, 'getItem').and.returnValue(access); // spyOn<any>(jwtHelper, 'decodeToken')\n    //     .and.returnValue(throwError('someError'));\n\n    spyOn(jwtHelper, 'decodeToken').and.throwError('someError');\n    let actualIsToken;\n    actualIsToken = authService.isToken(\"access\"); // Now verify emitted valued.\n\n    expect(actualIsToken).toEqual(false);\n  });\n  it('Token check pass with empty token', () => {\n    let access = \"\";\n    spyOn(window.localStorage, 'getItem').and.returnValue(access);\n    spyOn(jwtHelper, 'decodeToken').and.throwError('someError');\n    let actualIsToken;\n    actualIsToken = authService.isToken(\"access\"); // Now verify emitted valued.\n\n    expect(actualIsToken).toEqual(false);\n  });\n  it('Authentication state pass with alive token', () => {\n    spyOn(authService, 'isBothTokensAlive').and.returnValue(of(true));\n    spyOn(authService, 'isToken').and.returnValue(true);\n    let actualIsAuth;\n    authService.authState().subscribe(isAuth => {\n      actualIsAuth = isAuth;\n    });\n    expect(actualIsAuth).toEqual(true);\n  });\n  it('Authentication state pass with empty ACCESS token', () => {\n    spyOn(authService, 'isToken').and.returnValue(false);\n    let actualIsAuth;\n    authService.authState().subscribe(isAuth => {\n      actualIsAuth = isAuth;\n    });\n    expect(actualIsAuth).toEqual(false);\n  });\n  it('authChangeNotifier() & router.navigate should be called when authSuccessfully', () => {\n    let router = TestBed.inject(Router);\n    spyOn(router, 'navigate'); // .and.returnValue(false);\n\n    spyOn(authService, 'authChangeNotifier');\n    authService.authSuccessfully();\n    expect(authService.authChangeNotifier).toHaveBeenCalled();\n    expect(router.navigate).toHaveBeenCalled();\n  });\n  it('localStorage.removeItem & authChangeNotifier() & router.navigate should be called when logout', () => {\n    let router = TestBed.inject(Router);\n    spyOn(router, 'navigate'); // .and.returnValue(false);\n\n    spyOn(authService, 'authChangeNotifier');\n    spyOn(window.localStorage, 'removeItem');\n    authService.logout();\n    expect(localStorage.removeItem).toHaveBeenCalled();\n    expect(authService.authChangeNotifier).toHaveBeenCalled();\n    expect(router.navigate).toHaveBeenCalled();\n    expect(router.navigate).toHaveBeenCalledWith(['/login']);\n  });\n  it('authChange$.next should be called when authChangeNotifier', () => {\n    spyOn(authService.authChange$, 'next');\n    authService.authChangeNotifier(true);\n    expect(authService.authChange$.next).toHaveBeenCalled(); // expect(router.navigate).toHaveBeenCalled();\n\n    expect(authService.authChange$.next).toHaveBeenCalledWith(true);\n  });\n});","map":{"version":3,"sources":["C:/Users/Me/Documents/Me/fullstack/frontend-v02/src/app/auth/auth.service.spec.ts"],"names":["AuthService","TestBed","HttpClientTestingModule","HttpTestingController","RouterTestingModule","JwtHelperService","JwtModule","UIService","of","Router","validAuthData","email","password","name","invalidAuthData","uiServiceSpy","jasmine","createSpyObj","loadingStateNotifier","undefined","showSnackBar","actualIsLoadingState","describe","authService","jwtHelper","controller","beforeEach","configureTestingModule","imports","forRoot","config","tokenGetter","providers","provide","useValue","inject","it","response","registerUser","subscribe","isLoadingState","console","log","request","expectOne","method","url","flush","verify","expect","toEqual","status","statusText","errorEvent","ErrorEvent","actualError","login","spyOn","and","returnValue","actualIsAuth","refreshTokenOrDie","isAuth","refresh","localStorage","getItem","actualIsBothTokensAlive","isBothTokensAlive","access","window","actualIsToken","isToken","throwError","authState","router","authSuccessfully","authChangeNotifier","toHaveBeenCalled","navigate","logout","removeItem","toHaveBeenCalledWith","authChange$","next"],"mappings":"AAAA,SAASA,WAAT,QAA4B,gBAA5B;AACA,SAASC,OAAT,QAAwB,uBAAxB;AACA,SAASC,uBAAT,EAAkCC,qBAAlC,QAA+D,8BAA/D;AACA,SAASC,mBAAT,QAAoC,yBAApC;AACA,SAASC,gBAAT,EAA2BC,SAA3B,QAA4C,oBAA5C;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,EAAT,QAAmB,MAAnB;AACA,SAASC,MAAT,QAAuB,iBAAvB;AACA,MAAMC,aAAa,GAAG;AAClBC,EAAAA,KAAK,EAAE,eADW;AAElBC,EAAAA,QAAQ,EAAE,UAFQ;AAGlBC,EAAAA,IAAI,EAAE;AAHY,CAAtB;AAKA,MAAMC,eAAe,GAAG;AACpBH,EAAAA,KAAK,EAAE,EADa;AAEpBC,EAAAA,QAAQ,EAAE,EAFU;AAGpBC,EAAAA,IAAI,EAAE;AAHc,CAAxB;AAKA,MAAME,YAAY,GAAGC,OAAO,CAACC,YAAR,CAAqB,WAArB,EAAkC;AACnDC,EAAAA,oBAAoB,EAAEC,SAD6B;AAEnDC,EAAAA,YAAY,EAAED;AAFqC,CAAlC,CAArB;AAIA,IAAIE,oBAAJ,C,CACA;;AACAC,QAAQ,CAAC,aAAD,EAAgB,MAAM;AAC1B,MAAIC,WAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,UAAJ;AACAC,EAAAA,UAAU,CAAC,MAAM;AACbzB,IAAAA,OAAO,CAAC0B,sBAAR,CAA+B;AAC3BC,MAAAA,OAAO,EAAE,CACLxB,mBADK,EAELF,uBAFK,EAGLI,SAAS,CAACuB,OAAV,CAAkB;AACdC,QAAAA,MAAM,EAAE;AACJC,UAAAA,WAAW,EAAE,MAAM;AACf,mBAAO,EAAP;AACH;AAHG;AADM,OAAlB,CAHK,CADkB;AAY3BC,MAAAA,SAAS,EAAE,CACP;AACIC,QAAAA,OAAO,EAAE1B,SADb;AAEI2B,QAAAA,QAAQ,EAAEnB;AAFd,OADO,EAKPf,WALO,EAMPK,gBANO;AAZgB,KAA/B;AAqBAkB,IAAAA,WAAW,GAAGtB,OAAO,CAACkC,MAAR,CAAenC,WAAf,CAAd;AACAwB,IAAAA,SAAS,GAAGvB,OAAO,CAACkC,MAAR,CAAe9B,gBAAf,CAAZ;AACAoB,IAAAA,UAAU,GAAGxB,OAAO,CAACkC,MAAR,CAAehC,qBAAf,CAAb;AACAkB,IAAAA,oBAAoB,GAAG,IAAvB,CAzBa,CA0Bb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,GAnCS,CAAV;AAoCAe,EAAAA,EAAE,CAAC,4BAAD,EAA+B,MAAM;AACnC,UAAMC,QAAQ,GAAG;AACb,kBAAY,0BADC;AAEb,YAAM,CAFO;AAGb,eAAS,eAHI;AAIb,eAAS;AACL,mBAAW,iNADN;AAEL,kBAAU;AAFL;AAJI,KAAjB;AASAd,IAAAA,WAAW,CAACe,YAAZ,CAAyB5B,aAAzB,EAAwC6B,SAAxC,CAAmDC,cAAD,IAAoB;AAClEnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD;AAGAC,IAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYjB,UAAZ;AACA,UAAMkB,OAAO,GAAGlB,UAAU,CAACmB,SAAX,CAAqB;AACjCC,MAAAA,MAAM,EAAE,MADyB;AAEjCC,MAAAA,GAAG,EAAE;AAF4B,KAArB,CAAhB,CAfmC,CAmBnC;;AACAL,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYC,OAAZ;AACA;AACA;;AACAA,IAAAA,OAAO,CAACI,KAAR,CAAcV,QAAd;AACAZ,IAAAA,UAAU,CAACuB,MAAX,GAzBmC,CA0BnC;;AACAC,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,IAArC;AACH,GA5BC,CAAF;AA6BAd,EAAAA,EAAE,CAAC,4CAAD,EAA+C,MAAM;AACnDb,IAAAA,WAAW,CAACe,YAAZ,CAAyB5B,aAAzB,EAAwC6B,SAAxC,CAAmDC,cAAD,IAAoB;AAClEnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD;AAGAf,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAIKC,KAJL,CAIW,IAJX;AAKAE,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC;AACH,GAVC,CAAF;AAWAd,EAAAA,EAAE,CAAC,iDAAD,EAAoD,MAAM;AACxD,UAAMC,QAAQ,GAAG;AACb,eAAS,CACL,sCADK;AADI,KAAjB;AAKAd,IAAAA,WAAW,CAACe,YAAZ,CAAyB5B,aAAzB,EAAwC6B,SAAxC,CAAmDC,cAAD,IAAoB;AAClEnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD;AAGAf,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAIKC,KAJL,CAIWV,QAJX;AAKAY,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC;AACH,GAfC,CAAF;AAgBAd,EAAAA,EAAE,CAAC,iDAAD,EAAoD,MAAM;AACxD,UAAMe,MAAM,GAAG,GAAf;AACA,UAAMC,UAAU,GAAG,uBAAnB;AACA,UAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAe,WAAf,CAAnB,CAHwD,CAIxD;AACA;AACA;AACA;AACA;;AACA,QAAIC,WAAJ;AACAhC,IAAAA,WAAW,CAACe,YAAZ,CAAyB5B,aAAzB,EAAwC6B,SAAxC,CAAmDC,cAAD,IAAoB;AAClEnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD,EAVwD,CAaxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAf,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAIKC,KAJL,CAIWM,UAJX,EAIuB;AAAEF,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAJvB,EAxBwD,CA6BxD;;AACAH,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC,EA9BwD,CA+BxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,GAvCC,CAAF;AAwCAd,EAAAA,EAAE,CAAC,yBAAD,EAA4B,MAAM;AAChC,UAAMC,QAAQ,GAAG;AACb,iBAAW,iNADE;AAEb,gBAAU;AAFG,KAAjB;AAIAd,IAAAA,WAAW,CAACiC,KAAZ,CAAkB9C,aAAlB,EAAiC6B,SAAjC,CAA4CC,cAAD,IAAoB;AAC3DnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD;AAGA,UAAMG,OAAO,GAAGlB,UAAU,CAACmB,SAAX,CAAqB;AACjCC,MAAAA,MAAM,EAAE,MADyB;AAEjCC,MAAAA,GAAG,EAAE;AAF4B,KAArB,CAAhB,CARgC,CAYhC;;AACAH,IAAAA,OAAO,CAACI,KAAR,CAAcV,QAAd;AACAZ,IAAAA,UAAU,CAACuB,MAAX,GAdgC,CAehC;;AACAC,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,IAArC;AACH,GAjBC,CAAF;AAkBAd,EAAAA,EAAE,CAAC,6CAAD,EAAgD,MAAM;AACpDb,IAAAA,WAAW,CAACiC,KAAZ,CAAkB1C,eAAlB,EAAmCyB,SAAnC,CAA8CC,cAAD,IAAoB;AAC7DnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD,EADoD,CAIpD;AACA;AACA;AACA;AACA;AACA;AACA;;AACAS,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC;AACH,GAZC,CAAF;AAaAd,EAAAA,EAAE,CAAC,0CAAD,EAA6C,MAAM;AACjD,UAAMe,MAAM,GAAG,GAAf;AACA,UAAMC,UAAU,GAAG,uBAAnB;AACA,UAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAe,WAAf,CAAnB,CAHiD,CAIjD;AACA;AACA;AACA;AACA;;AACA,QAAIC,WAAJ;AACAhC,IAAAA,WAAW,CAACiC,KAAZ,CAAkB9C,aAAlB,EAAiC6B,SAAjC,CAA4CC,cAAD,IAAoB;AAC3DnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD,EAViD,CAajD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAf,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAIKC,KAJL,CAIWM,UAJX,EAIuB;AAAEF,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAJvB,EAxBiD,CA6BjD;;AACAH,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC,EA9BiD,CA+BjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,GAvCC,CAAF;AAwCAd,EAAAA,EAAE,CAAC,qCAAD,EAAwC,MAAM;AAC5Cb,IAAAA,WAAW,CAACiC,KAAZ,CAAkB9C,aAAlB,EAAiC6B,SAAjC,CAA4CC,cAAD,IAAoB;AAC3DnB,MAAAA,oBAAoB,GAAGmB,cAAvB;AACH,KAFD;AAGAf,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAIKC,KAJL,CAIW,IAJX;AAKAE,IAAAA,MAAM,CAAC5B,oBAAD,CAAN,CAA6B6B,OAA7B,CAAqC,KAArC;AACH,GAVC,CAAF,CA/M0B,CA0N1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACAd,EAAAA,EAAE,CAAC,mCAAD,EAAsC,MAAM;AAC1CqB,IAAAA,KAAK,CAAClC,WAAD,EAAc,UAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,MADrB;AAEAF,IAAAA,KAAK,CAAClC,WAAD,EAAc,SAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,IADrB,EAH0C,CAK1C;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMtB,QAAQ,GAAG;AACb,gBAAU;AADG,KAAjB;AAGA,QAAIuB,YAAJ;AACArC,IAAAA,WAAW,CAACsC,iBAAZ,GAAgCtB,SAAhC,CAA2CuB,MAAD,IAAY;AAClDF,MAAAA,YAAY,GAAGE,MAAf;AACH,KAFD;AAGA,UAAMnB,OAAO,GAAGlB,UAAU,CAACmB,SAAX,CAAqB;AACjCC,MAAAA,MAAM,EAAE,MADyB;AAEjCC,MAAAA,GAAG,EAAE;AAF4B,KAArB,CAAhB,CAlB0C,CAsB1C;;AACAH,IAAAA,OAAO,CAACI,KAAR,CAAcV,QAAd;AACAZ,IAAAA,UAAU,CAACuB,MAAX,GAxB0C,CAyB1C;;AACA,QAAIe,OAAO,GAAGC,YAAY,CAACC,OAAb,CAAqB,SAArB,CAAd;AACAxB,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2B,iDAA3B;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAYqB,OAAZ,EA7B0C,CA8B1C;;AACAd,IAAAA,MAAM,CAACW,YAAD,CAAN,CAAqBV,OAArB,CAA6B,IAA7B;AACH,GAhCC,CAAF;AAiCAd,EAAAA,EAAE,CAAC,yEAAD,EAA4E,MAAM;AAChFqB,IAAAA,KAAK,CAAClC,WAAD,EAAc,UAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,MADrB;AAEAF,IAAAA,KAAK,CAAClC,WAAD,EAAc,SAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,KADrB;AAEA,QAAIC,YAAJ;AACArC,IAAAA,WAAW,CAACsC,iBAAZ,GAAgCtB,SAAhC,CAA2CuB,MAAD,IAAY;AAClDF,MAAAA,YAAY,GAAGE,MAAf;AACH,KAFD,EANgF,CAShF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAb,IAAAA,MAAM,CAACW,YAAD,CAAN,CAAqBV,OAArB,CAA6B,KAA7B;AACH,GAtBC,CAAF;AAuBAd,EAAAA,EAAE,CAAC,yDAAD,EAA4D,MAAM;AAChE,UAAMe,MAAM,GAAG,GAAf;AACA,UAAMC,UAAU,GAAG,uBAAnB;AACA,UAAMC,UAAU,GAAG,IAAIC,UAAJ,CAAe,WAAf,CAAnB;AACAG,IAAAA,KAAK,CAAClC,WAAD,EAAc,SAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,IADrB;AAEA,QAAIC,YAAJ;AACArC,IAAAA,WAAW,CAACsC,iBAAZ,GAAgCtB,SAAhC,CAA2CuB,MAAD,IAAY;AAClDF,MAAAA,YAAY,GAAGE,MAAf;AACH,KAFD;AAGArC,IAAAA,UAAU,CAACmB,SAAX,CAAqB;AACjBC,MAAAA,MAAM,EAAE,MADS;AAEjBC,MAAAA,GAAG,EAAE;AAFY,KAArB,EAGGC,KAHH,CAGSM,UAHT,EAGqB;AAAEF,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAHrB;AAIAH,IAAAA,MAAM,CAACW,YAAD,CAAN,CAAqBV,OAArB,CAA6B,KAA7B;AACH,GAfC,CAAF;AAgBAd,EAAAA,EAAE,CAAC,qBAAD,EAAwB,MAAM;AAC5BqB,IAAAA,KAAK,CAACjC,SAAD,EAAY,gBAAZ,CAAL,CACKkC,GADL,CACSC,WADT,CACqB,KADrB;AAEA,QAAIO,uBAAJ;AACA3C,IAAAA,WAAW,CAAC4C,iBAAZ,GAAgC5B,SAAhC,CAA2C4B,iBAAD,IAAuB;AAC7DD,MAAAA,uBAAuB,GAAGC,iBAA1B;AACH,KAFD,EAJ4B,CAO5B;;AACAlB,IAAAA,MAAM,CAACiB,uBAAD,CAAN,CAAgChB,OAAhC,CAAwC,IAAxC;AACH,GATC,CAAF;AAUAd,EAAAA,EAAE,CAAC,6BAAD,EAAgC,MAAM;AACpCqB,IAAAA,KAAK,CAACjC,SAAD,EAAY,gBAAZ,CAAL,CACKkC,GADL,CACSC,WADT,CACqB,IADrB;AAEAF,IAAAA,KAAK,CAAClC,WAAD,EAAc,mBAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqBnD,EAAE,CAAC,IAAD,CADvB;AAEA,QAAI0D,uBAAJ;AACA3C,IAAAA,WAAW,CAAC4C,iBAAZ,GAAgC5B,SAAhC,CAA2C4B,iBAAD,IAAuB;AAC7DD,MAAAA,uBAAuB,GAAGC,iBAA1B;AACH,KAFD,EANoC,CASpC;;AACAlB,IAAAA,MAAM,CAACiB,uBAAD,CAAN,CAAgChB,OAAhC,CAAwC,IAAxC;AACH,GAXC,CAAF;AAYAd,EAAAA,EAAE,CAAC,mCAAD,EAAsC,MAAM;AAC1C,QAAIgC,MAAM,GAAG,MAAb;AACAX,IAAAA,KAAK,CAACY,MAAM,CAACL,YAAR,EAAsB,SAAtB,CAAL,CACKN,GADL,CACSC,WADT,CACqBS,MADrB;AAEAX,IAAAA,KAAK,CAACjC,SAAD,EAAY,aAAZ,CAAL,CACKkC,GADL,CACSC,WADT,CACqB,OADrB;AAEA,QAAIW,aAAJ;AACAA,IAAAA,aAAa,GAAG/C,WAAW,CAACgD,OAAZ,CAAoB,QAApB,CAAhB,CAP0C,CAQ1C;;AACAtB,IAAAA,MAAM,CAACqB,aAAD,CAAN,CAAsBpB,OAAtB,CAA8B,IAA9B;AACH,GAVC,CAAF;AAWAd,EAAAA,EAAE,CAAC,qCAAD,EAAwC,MAAM;AAC5C,QAAIgC,MAAM,GAAG,MAAb;AACAX,IAAAA,KAAK,CAACY,MAAM,CAACL,YAAR,EAAsB,SAAtB,CAAL,CACKN,GADL,CACSC,WADT,CACqBS,MADrB,EAF4C,CAI5C;AACA;;AACAX,IAAAA,KAAK,CAACjC,SAAD,EAAY,aAAZ,CAAL,CACKkC,GADL,CACSc,UADT,CACoB,WADpB;AAEA,QAAIF,aAAJ;AACAA,IAAAA,aAAa,GAAG/C,WAAW,CAACgD,OAAZ,CAAoB,QAApB,CAAhB,CAT4C,CAU5C;;AACAtB,IAAAA,MAAM,CAACqB,aAAD,CAAN,CAAsBpB,OAAtB,CAA8B,KAA9B;AACH,GAZC,CAAF;AAaAd,EAAAA,EAAE,CAAC,mCAAD,EAAsC,MAAM;AAC1C,QAAIgC,MAAM,GAAG,EAAb;AACAX,IAAAA,KAAK,CAACY,MAAM,CAACL,YAAR,EAAsB,SAAtB,CAAL,CACKN,GADL,CACSC,WADT,CACqBS,MADrB;AAEAX,IAAAA,KAAK,CAACjC,SAAD,EAAY,aAAZ,CAAL,CACKkC,GADL,CACSc,UADT,CACoB,WADpB;AAEA,QAAIF,aAAJ;AACAA,IAAAA,aAAa,GAAG/C,WAAW,CAACgD,OAAZ,CAAoB,QAApB,CAAhB,CAP0C,CAQ1C;;AACAtB,IAAAA,MAAM,CAACqB,aAAD,CAAN,CAAsBpB,OAAtB,CAA8B,KAA9B;AACH,GAVC,CAAF;AAWAd,EAAAA,EAAE,CAAC,4CAAD,EAA+C,MAAM;AACnDqB,IAAAA,KAAK,CAAClC,WAAD,EAAc,mBAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqBnD,EAAE,CAAC,IAAD,CADvB;AAEAiD,IAAAA,KAAK,CAAClC,WAAD,EAAc,SAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,IADrB;AAEA,QAAIC,YAAJ;AACArC,IAAAA,WAAW,CAACkD,SAAZ,GAAwBlC,SAAxB,CAAmCuB,MAAD,IAAY;AAC1CF,MAAAA,YAAY,GAAGE,MAAf;AACH,KAFD;AAGAb,IAAAA,MAAM,CAACW,YAAD,CAAN,CAAqBV,OAArB,CAA6B,IAA7B;AACH,GAVC,CAAF;AAWAd,EAAAA,EAAE,CAAC,mDAAD,EAAsD,MAAM;AAC1DqB,IAAAA,KAAK,CAAClC,WAAD,EAAc,SAAd,CAAL,CACKmC,GADL,CACSC,WADT,CACqB,KADrB;AAEA,QAAIC,YAAJ;AACArC,IAAAA,WAAW,CAACkD,SAAZ,GAAwBlC,SAAxB,CAAmCuB,MAAD,IAAY;AAC1CF,MAAAA,YAAY,GAAGE,MAAf;AACH,KAFD;AAGAb,IAAAA,MAAM,CAACW,YAAD,CAAN,CAAqBV,OAArB,CAA6B,KAA7B;AACH,GARC,CAAF;AASAd,EAAAA,EAAE,CAAC,+EAAD,EAAkF,MAAM;AACtF,QAAIsC,MAAM,GAAGzE,OAAO,CAACkC,MAAR,CAAe1B,MAAf,CAAb;AACAgD,IAAAA,KAAK,CAACiB,MAAD,EAAS,UAAT,CAAL,CAFsF,CAGtF;;AACAjB,IAAAA,KAAK,CAAClC,WAAD,EAAc,oBAAd,CAAL;AACAA,IAAAA,WAAW,CAACoD,gBAAZ;AACA1B,IAAAA,MAAM,CAAC1B,WAAW,CAACqD,kBAAb,CAAN,CAAuCC,gBAAvC;AACA5B,IAAAA,MAAM,CAACyB,MAAM,CAACI,QAAR,CAAN,CAAwBD,gBAAxB;AACH,GARC,CAAF;AASAzC,EAAAA,EAAE,CAAC,+FAAD,EAAkG,MAAM;AACtG,QAAIsC,MAAM,GAAGzE,OAAO,CAACkC,MAAR,CAAe1B,MAAf,CAAb;AACAgD,IAAAA,KAAK,CAACiB,MAAD,EAAS,UAAT,CAAL,CAFsG,CAGtG;;AACAjB,IAAAA,KAAK,CAAClC,WAAD,EAAc,oBAAd,CAAL;AACAkC,IAAAA,KAAK,CAACY,MAAM,CAACL,YAAR,EAAsB,YAAtB,CAAL;AACAzC,IAAAA,WAAW,CAACwD,MAAZ;AACA9B,IAAAA,MAAM,CAACe,YAAY,CAACgB,UAAd,CAAN,CAAgCH,gBAAhC;AACA5B,IAAAA,MAAM,CAAC1B,WAAW,CAACqD,kBAAb,CAAN,CAAuCC,gBAAvC;AACA5B,IAAAA,MAAM,CAACyB,MAAM,CAACI,QAAR,CAAN,CAAwBD,gBAAxB;AACA5B,IAAAA,MAAM,CAACyB,MAAM,CAACI,QAAR,CAAN,CAAwBG,oBAAxB,CAA6C,CAAC,QAAD,CAA7C;AACH,GAXC,CAAF;AAYA7C,EAAAA,EAAE,CAAC,2DAAD,EAA8D,MAAM;AAClEqB,IAAAA,KAAK,CAAClC,WAAW,CAAC2D,WAAb,EAA0B,MAA1B,CAAL;AACA3D,IAAAA,WAAW,CAACqD,kBAAZ,CAA+B,IAA/B;AACA3B,IAAAA,MAAM,CAAC1B,WAAW,CAAC2D,WAAZ,CAAwBC,IAAzB,CAAN,CAAqCN,gBAArC,GAHkE,CAIlE;;AACA5B,IAAAA,MAAM,CAAC1B,WAAW,CAAC2D,WAAZ,CAAwBC,IAAzB,CAAN,CAAqCF,oBAArC,CAA0D,IAA1D;AACH,GANC,CAAF;AAOH,CAlZO,CAAR","sourcesContent":["import { AuthService } from \"./auth.service\";\r\nimport { TestBed } from \"@angular/core/testing\";\r\nimport { HttpClientTestingModule, HttpTestingController } from \"@angular/common/http/testing\";\r\nimport { RouterTestingModule } from \"@angular/router/testing\";\r\nimport { JwtHelperService, JwtModule } from \"@auth0/angular-jwt\";\r\nimport { UIService } from \"../shared/ui.service\";\r\nimport { of } from \"rxjs\";\r\nimport { Router } from \"@angular/router\";\r\nconst validAuthData = {\r\n    email: \"test@test.com\",\r\n    password: \"password\",\r\n    name: \"test\"\r\n};\r\nconst invalidAuthData = {\r\n    email: \"\",\r\n    password: \"\",\r\n    name: \"\"\r\n};\r\nconst uiServiceSpy = jasmine.createSpyObj(\"UIService\", {\r\n    loadingStateNotifier: undefined,\r\n    showSnackBar: undefined\r\n});\r\nlet actualIsLoadingState;\r\n// let localStore: any;\r\ndescribe('AuthService', () => {\r\n    let authService;\r\n    let jwtHelper;\r\n    let controller;\r\n    beforeEach(() => {\r\n        TestBed.configureTestingModule({\r\n            imports: [\r\n                RouterTestingModule,\r\n                HttpClientTestingModule,\r\n                JwtModule.forRoot({\r\n                    config: {\r\n                        tokenGetter: () => {\r\n                            return '';\r\n                        }\r\n                    }\r\n                })\r\n            ],\r\n            providers: [\r\n                {\r\n                    provide: UIService,\r\n                    useValue: uiServiceSpy\r\n                },\r\n                AuthService,\r\n                JwtHelperService\r\n            ],\r\n        });\r\n        authService = TestBed.inject(AuthService);\r\n        jwtHelper = TestBed.inject(JwtHelperService);\r\n        controller = TestBed.inject(HttpTestingController);\r\n        actualIsLoadingState = null;\r\n        // localStore = {};\r\n        //\r\n        // spyOn(window.localStorage, 'getItem').and.callFake((key) =>\r\n        //     key in localStore ? localStore[key] : null\r\n        // );\r\n        // spyOn(window.localStorage, 'setItem').and.callFake(\r\n        //     (key, value) => (localStore[key] = value + '')\r\n        // );\r\n        // spyOn(window.localStorage, 'clear').and.callFake(() => (localStore = {}));\r\n    });\r\n    it('User register successfully', () => {\r\n        const response = {\r\n            \"response\": \"Registration Successful!\",\r\n            \"id\": 7,\r\n            \"email\": \"test@test.com\",\r\n            \"token\": {\r\n                \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\",\r\n                \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d4M\"\r\n            }\r\n        };\r\n        authService.registerUser(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        console.log(\"controller: \");\r\n        console.log(controller);\r\n        const request = controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/create/\"\r\n        });\r\n        // const request = controller.expectOne(\"api/user/create/\");\r\n        console.log(\"request: \");\r\n        console.log(request);\r\n        /* … */\r\n        // Answer the request so the Observable emits a value.\r\n        request.flush(response);\r\n        controller.verify();\r\n        // Now verify emitted valued.\r\n        expect(actualIsLoadingState).toEqual(true);\r\n    });\r\n    it('Registration passes through empty response', () => {\r\n        authService.registerUser(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/create/\"\r\n        })\r\n            .flush(null);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n    });\r\n    it('Registration passes through email already exist', () => {\r\n        const response = {\r\n            \"email\": [\r\n                \"user with this email already exists.\"\r\n            ]\r\n        };\r\n        authService.registerUser(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/create/\"\r\n        })\r\n            .flush(response);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n    });\r\n    it('Registration passes through with error response', () => {\r\n        const status = 500;\r\n        const statusText = 'Internal Server Error';\r\n        const errorEvent = new ErrorEvent('API error');\r\n        // const error = {\r\n        //     \"email\": [\r\n        //         \"user with this email already exists.\"\r\n        //     ]\r\n        // }\r\n        let actualError;\r\n        authService.registerUser(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        // authService.registerUser(validAuthData).subscribe(\r\n        //     () => {\r\n        //         fail('next handler must not be called');\r\n        //     },\r\n        //     (error) => {\r\n        //         actualError = error;\r\n        //     },\r\n        //     () => {\r\n        //         fail('complete handler must not be called');\r\n        //     },\r\n        // );\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/create/\"\r\n        })\r\n            .flush(errorEvent, { status, statusText });\r\n        // .flush(error);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n        // if (!actualError) {\r\n        //     throw new Error('Error needs to be defined');\r\n        // }\r\n        // console.log(\"actualError: \");\r\n        // console.log(actualError);\r\n        // expect(actualError.error).toBe(errorEvent);\r\n        // expect(actualError.status).toBe(status);\r\n        // expect(actualError.statusText).toBe(statusText);\r\n    });\r\n    it('User login successfully', () => {\r\n        const response = {\r\n            \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\",\r\n            \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d4M\"\r\n        };\r\n        authService.login(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        const request = controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/access/\"\r\n        });\r\n        // Answer the request so the Observable emits a value.\r\n        request.flush(response);\r\n        controller.verify();\r\n        // Now verify emitted valued.\r\n        expect(actualIsLoadingState).toEqual(true);\r\n    });\r\n    it('Login passes through user form fields empty', () => {\r\n        authService.login(invalidAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        // controller.expectOne(\r\n        //     {\r\n        //         method: \"POST\",\r\n        //         url: \"api/user/access/\"\r\n        //     }\r\n        // )\r\n        //     .flush(null);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n    });\r\n    it('Login passes through with error response', () => {\r\n        const status = 500;\r\n        const statusText = 'Internal Server Error';\r\n        const errorEvent = new ErrorEvent('API error');\r\n        // const error = {\r\n        //     \"email\": [\r\n        //         \"user with this email already exists.\"\r\n        //     ]\r\n        // }\r\n        let actualError;\r\n        authService.login(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        // authService.registerUser(validAuthData).subscribe(\r\n        //     () => {\r\n        //         fail('next handler must not be called');\r\n        //     },\r\n        //     (error) => {\r\n        //         actualError = error;\r\n        //     },\r\n        //     () => {\r\n        //         fail('complete handler must not be called');\r\n        //     },\r\n        // );\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/access/\"\r\n        })\r\n            .flush(errorEvent, { status, statusText });\r\n        // .flush(error);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n        // if (!actualError) {\r\n        //     throw new Error('Error needs to be defined');\r\n        // }\r\n        // console.log(\"actualError: \");\r\n        // console.log(actualError);\r\n        // expect(actualError.error).toBe(errorEvent);\r\n        // expect(actualError.status).toBe(status);\r\n        // expect(actualError.statusText).toBe(statusText);\r\n    });\r\n    it('Login passes through empty response', () => {\r\n        authService.login(validAuthData).subscribe((isLoadingState) => {\r\n            actualIsLoadingState = isLoadingState;\r\n        });\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"api/user/access/\"\r\n        })\r\n            .flush(null);\r\n        expect(actualIsLoadingState).toEqual(false);\r\n    });\r\n    // it('InitAuthListener', async () => {\r\n    //\r\n    //     await authService.initAuthListener()\r\n    //\r\n    //     expect(true).toEqual(true);\r\n    //\r\n    // });\r\n    it('Refresh access token successfully', () => {\r\n        spyOn(authService, 'getToken')\r\n            .and.returnValue(\"test\");\r\n        spyOn(authService, 'isToken')\r\n            .and.returnValue(true);\r\n        // const payload = {\r\n        //     \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH4\"\r\n        // }\r\n        // const payload = {\r\n        //     \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTYzOTgxOTIxOCwianRpIjoiODQ1ODcyMmI5OWVjNDc4NmJkNjZmMTI1ZjIwZjE5MWMiLCJ1c2VyX2lkIjo3fQ.BloTHDQ6OBRwksiLzJxrWKnnGn-8L6ClzEeJTN4QmH8\"\r\n        // }\r\n        const response = {\r\n            \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjM5NzM0NjE4LCJqdGkiOiI1MzljNzgyYjk3YTc0ZmY0OGIxNGQ0MjZjMmU3Mjg4MSIsInVzZXJfaWQiOjd9.E3WLyrGwvJQhXevTH3o7vCyEQnmBKw1xEbe5oNZ0d8M\"\r\n        };\r\n        let actualIsAuth;\r\n        authService.refreshTokenOrDie().subscribe((isAuth) => {\r\n            actualIsAuth = isAuth;\r\n        });\r\n        const request = controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"/api/user/refresh/\"\r\n        });\r\n        // Answer the request so the Observable emits a value.\r\n        request.flush(response);\r\n        controller.verify();\r\n        // localStorage.removeItem('refresh');\r\n        let refresh = localStorage.getItem('refresh');\r\n        console.log(\"refresh: \");\r\n        console.log('%c refresh ', 'background: yellow; color: #000; padding: 10px;');\r\n        console.log(refresh);\r\n        // Now verify emitted valued.\r\n        expect(actualIsAuth).toEqual(true);\r\n    });\r\n    it('Refresh ACCESS token passes through when empty or invalid REFRESH Token', () => {\r\n        spyOn(authService, 'getToken')\r\n            .and.returnValue(\"test\");\r\n        spyOn(authService, 'isToken')\r\n            .and.returnValue(false);\r\n        let actualIsAuth;\r\n        authService.refreshTokenOrDie().subscribe((isAuth) => {\r\n            actualIsAuth = isAuth;\r\n        });\r\n        //\r\n        // const request = controller.expectOne(\r\n        //     {\r\n        //         method: \"POST\",\r\n        //         url: \"/api/user/refresh/\"\r\n        //     }\r\n        // );\r\n        //\r\n        // Answer the request so the Observable emits a value.\r\n        // request.flush(response);\r\n        // controller.verify();\r\n        // Now verify emitted valued.\r\n        expect(actualIsAuth).toEqual(false);\r\n    });\r\n    it('Refresh ACCESS token passes through with error response', () => {\r\n        const status = 500;\r\n        const statusText = 'Internal Server Error';\r\n        const errorEvent = new ErrorEvent('API error');\r\n        spyOn(authService, 'isToken')\r\n            .and.returnValue(true);\r\n        let actualIsAuth;\r\n        authService.refreshTokenOrDie().subscribe((isAuth) => {\r\n            actualIsAuth = isAuth;\r\n        });\r\n        controller.expectOne({\r\n            method: \"POST\",\r\n            url: \"/api/user/refresh/\"\r\n        }).flush(errorEvent, { status, statusText });\r\n        expect(actualIsAuth).toEqual(false);\r\n    });\r\n    it('ACCESS tokens alive', () => {\r\n        spyOn(jwtHelper, 'isTokenExpired')\r\n            .and.returnValue(false);\r\n        let actualIsBothTokensAlive;\r\n        authService.isBothTokensAlive().subscribe((isBothTokensAlive) => {\r\n            actualIsBothTokensAlive = isBothTokensAlive;\r\n        });\r\n        // Now verify emitted valued.\r\n        expect(actualIsBothTokensAlive).toEqual(true);\r\n    });\r\n    it('REFRESH tokens alive or not', () => {\r\n        spyOn(jwtHelper, 'isTokenExpired')\r\n            .and.returnValue(true);\r\n        spyOn(authService, 'refreshTokenOrDie')\r\n            .and.returnValue(of(true));\r\n        let actualIsBothTokensAlive;\r\n        authService.isBothTokensAlive().subscribe((isBothTokensAlive) => {\r\n            actualIsBothTokensAlive = isBothTokensAlive;\r\n        });\r\n        // Now verify emitted valued.\r\n        expect(actualIsBothTokensAlive).toEqual(true);\r\n    });\r\n    it('Token check pass with valid token', () => {\r\n        let access = \"test\";\r\n        spyOn(window.localStorage, 'getItem')\r\n            .and.returnValue(access);\r\n        spyOn(jwtHelper, 'decodeToken')\r\n            .and.returnValue(\"valid\");\r\n        let actualIsToken;\r\n        actualIsToken = authService.isToken(\"access\");\r\n        // Now verify emitted valued.\r\n        expect(actualIsToken).toEqual(true);\r\n    });\r\n    it('Token check pass with invalid token', () => {\r\n        let access = \"test\";\r\n        spyOn(window.localStorage, 'getItem')\r\n            .and.returnValue(access);\r\n        // spyOn<any>(jwtHelper, 'decodeToken')\r\n        //     .and.returnValue(throwError('someError'));\r\n        spyOn(jwtHelper, 'decodeToken')\r\n            .and.throwError('someError');\r\n        let actualIsToken;\r\n        actualIsToken = authService.isToken(\"access\");\r\n        // Now verify emitted valued.\r\n        expect(actualIsToken).toEqual(false);\r\n    });\r\n    it('Token check pass with empty token', () => {\r\n        let access = \"\";\r\n        spyOn(window.localStorage, 'getItem')\r\n            .and.returnValue(access);\r\n        spyOn(jwtHelper, 'decodeToken')\r\n            .and.throwError('someError');\r\n        let actualIsToken;\r\n        actualIsToken = authService.isToken(\"access\");\r\n        // Now verify emitted valued.\r\n        expect(actualIsToken).toEqual(false);\r\n    });\r\n    it('Authentication state pass with alive token', () => {\r\n        spyOn(authService, 'isBothTokensAlive')\r\n            .and.returnValue(of(true));\r\n        spyOn(authService, 'isToken')\r\n            .and.returnValue(true);\r\n        let actualIsAuth;\r\n        authService.authState().subscribe((isAuth) => {\r\n            actualIsAuth = isAuth;\r\n        });\r\n        expect(actualIsAuth).toEqual(true);\r\n    });\r\n    it('Authentication state pass with empty ACCESS token', () => {\r\n        spyOn(authService, 'isToken')\r\n            .and.returnValue(false);\r\n        let actualIsAuth;\r\n        authService.authState().subscribe((isAuth) => {\r\n            actualIsAuth = isAuth;\r\n        });\r\n        expect(actualIsAuth).toEqual(false);\r\n    });\r\n    it('authChangeNotifier() & router.navigate should be called when authSuccessfully', () => {\r\n        let router = TestBed.inject(Router);\r\n        spyOn(router, 'navigate');\r\n        // .and.returnValue(false);\r\n        spyOn(authService, 'authChangeNotifier');\r\n        authService.authSuccessfully();\r\n        expect(authService.authChangeNotifier).toHaveBeenCalled();\r\n        expect(router.navigate).toHaveBeenCalled();\r\n    });\r\n    it('localStorage.removeItem & authChangeNotifier() & router.navigate should be called when logout', () => {\r\n        let router = TestBed.inject(Router);\r\n        spyOn(router, 'navigate');\r\n        // .and.returnValue(false);\r\n        spyOn(authService, 'authChangeNotifier');\r\n        spyOn(window.localStorage, 'removeItem');\r\n        authService.logout();\r\n        expect(localStorage.removeItem).toHaveBeenCalled();\r\n        expect(authService.authChangeNotifier).toHaveBeenCalled();\r\n        expect(router.navigate).toHaveBeenCalled();\r\n        expect(router.navigate).toHaveBeenCalledWith(['/login']);\r\n    });\r\n    it('authChange$.next should be called when authChangeNotifier', () => {\r\n        spyOn(authService.authChange$, 'next');\r\n        authService.authChangeNotifier(true);\r\n        expect(authService.authChange$.next).toHaveBeenCalled();\r\n        // expect(router.navigate).toHaveBeenCalled();\r\n        expect(authService.authChange$.next).toHaveBeenCalledWith(true);\r\n    });\r\n});\r\n"]},"metadata":{},"sourceType":"module"}